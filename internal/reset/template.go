package reset

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/format"
	"go/token"
	"strings"
	"text/template"
)

const templateStr = `// Code generated by go generate; DO NOT EDIT.
// This file was generated by cmd/reset/

package {{.Name}}


{{if .Structs}}
{{range $struct := .Structs}}
func ({{$struct.Name}} *{{$struct.Name}}) Reset() {
if {{$struct.Name}} == nil {
    return
}
{{range $struct.Fields}}	{{zeroValue .Type $struct.Name .Name}}
{{end}}
}

{{end}}
{{end}}
`

func GenerateResetTemplate(PackageInfo PackageInfo) []byte {
	var tmpl = template.Must(template.New("reset").Funcs(template.FuncMap{
		"zeroValue": zeroValue,
	}).Parse(templateStr))
	// генерируем код по шаблону
	var buf bytes.Buffer
	fmt.Println("PackageInfo", PackageInfo)
	err := tmpl.Execute(&buf, PackageInfo)
	if err != nil {
		panic(err)
	}

	// форматируем код
	bufFmt, err := format.Source(buf.Bytes())
	if err != nil {
		panic(err)
	}
	return bufFmt

}

func zeroValue(expr ast.Expr, structName, fieldName string) string {
	fullFieldName := structName + "." + fieldName
	switch t := expr.(type) {
	case *ast.Ident:
		// Базовые примитивы
		switch t.Name {
		case "int", "int64", "uint", "uint64":
			return fullFieldName + " = " + "0"
		case "float64", "float32":
			return fullFieldName + " = " + "0"
		case "string":
			return fullFieldName + " = " + `""`
		case "bool":
			return fullFieldName + " = " + "false"
		default:
			// структуры вернем конструктор типа
			return fullFieldName + " = " + t.Name + "{}"
		}

	case *ast.StarExpr:
		// указатель: если не nil, сбрасываем содержимое рекурсивно
		// на основе этого узнаем к каким типам он относится, примитивным или нет
		baseType := t.X
		resetCode := zeroValue(baseType, structName, fieldName)
		// для примитивов и структур с Reset
		if strings.Contains(resetCode, " = 0") || strings.Contains(resetCode, " = \"\"") || strings.Contains(resetCode, " = false") {
			// присваиваем разыменованное значение
			return fmt.Sprintf("if %s != nil {\n    *%s = \"\"\n}", fullFieldName, fullFieldName)
		}
		// для вложенных структур с Reset

		return fmt.Sprintf("if %s != nil {\n    var resetter interface{} = %s\n			if r, ok := resetter.(interface{ Reset() }); ok {\n			r.Reset()}}", fullFieldName, fullFieldName)
		//return fmt.Sprintf("if %s != nil {\n    if resetter, ok := %s.(interface{ Reset() }); ok {\n        resetter.Reset()\n    }\n}", fullFieldName, fullFieldName)
	case *ast.ArrayType:
		// Срезы - обрезать длину
		return fullFieldName + " = " + fullFieldName + "[:0]"

	case *ast.MapType:
		// мапы очищаем через clear()
		return "clear(" + fullFieldName + ")"

	case *ast.StructType:
		// Inline структура - нет имени, сбрасываем через конструктор
		return fullFieldName + " = " + "{}"

	default:
		// пропускае значение
		return ""
	}
}

func exprToString(expr ast.Expr) string {
	var buf bytes.Buffer
	err := format.Node(&buf, token.NewFileSet(), expr)
	if err != nil {
		return ""
	}
	return buf.String()
}
